# Bradax SDK - Cliente Python Corporativo

> **SDK Python profissional para integra√ß√£o segura com o Bradax Broker. Inclui autentica√ß√£o por projeto, guardrails personalizados e telemetria local.**

## üéØ Vis√£o Geral

O Bradax SDK √© o cliente oficial para comunica√ß√£o com o Bradax Broker, projetado para ambientes corporativos que exigem controle total sobre opera√ß√µes de LLM.

```mermaid
graph LR
    APP[Aplica√ß√£o] --> SDK[Bradax SDK]
    SDK --> AUTH[Autentica√ß√£o]
    SDK --> GUARD[Guardrails Locais]
    SDK --> TELEM[Telemetria Local]
    SDK -->|HTTPS| BROKER[Bradax Broker]
    
    subgraph "SDK Components"
        CLIENT[BradaxClient]
        CONFIG[Configura√ß√£o]
        EXCEPT[Exce√ß√µes]
    end
```

## üöÄ Uso B√°sico

### Inicializa√ß√£o Simples
```python
from bradax import BradaxClient

# Cliente b√°sico
client = BradaxClient(
    project_token="proj_acme_2025_ai_assistant_001",
    broker_url="https://llm.empresa.com"
)

# Execu√ß√£o de LLM
response = client.run_llm(
    prompt="Analise este relat√≥rio de vendas...",
    model="gpt-4o-mini",
    max_tokens=1000
)

print(response["content"])
```

### Configura√ß√£o Avan√ßada
```python
from bradax import BradaxClient
from bradax.config import BradaxSDKConfig

# Configura√ß√£o personalizada
config = BradaxSDKConfig.from_environment()
config.set_custom_guardrail("content_safety", {
    "max_chars": 5000,
    "forbidden_patterns": ["senha", "cpf"],
    "check_encoding": "utf-8"
})

# Cliente com configura√ß√£o
client = BradaxClient(
    project_token="proj_acme_2025_ai_assistant_001",
    config=config
)
```

## üõ°Ô∏è Guardrails Personalizados

### Conceito Fundamental
- **Guardrails do Projeto:** Obrigat√≥rios, definidos no broker (N√ÉO podem ser desabilitados)
- **Guardrails Personalizados:** Opcionais, adicionados pelo SDK (COMPLEMENTAM os defaults)

### Adicionar Guardrails Locais
```python
# Guardrail de tamanho de conte√∫do
client.add_custom_guardrail("content_length", {
    "max_chars": 10000,
    "min_chars": 10,
    "check_empty": True
})

# Guardrail de filtro de conte√∫do
client.add_custom_guardrail("content_filter", {
    "forbidden_words": ["confidencial", "secreto"],
    "case_sensitive": False,
    "action": "block"  # ou "warn"
})

# Guardrail de valida√ß√£o de entrada
client.add_custom_guardrail("input_validation", {
    "require_question_mark": True,
    "max_sentences": 5,
    "language": "pt-BR"
})

# Listar guardrails ativos
guardrails = client.list_custom_guardrails()
print(f"Guardrails personalizados: {len(guardrails)}")
```

### Gerenciar Guardrails
```python
# Remover guardrail espec√≠fico
removed = client.remove_custom_guardrail("content_length")
if removed:
    print("Guardrail removido com sucesso")

# Verificar guardrails ativos
active_guards = client.list_custom_guardrails()
for name, config in active_guards.items():
    print(f"- {name}: {config}")
```

## üìä Telemetria Local

### Configura√ß√£o de Telemetria
```python
# A telemetria do PROJETO √© sempre obrigat√≥ria (definida no broker)
# Esta √© apenas a telemetria ADICIONAL local do SDK

# Verificar configura√ß√£o atual
telem_config = client.get_telemetry_config()
print(f"Telemetria local: {telem_config['local_enabled']}")
print(f"Buffer size: {telem_config['buffer_size']}")
print(f"Ambiente: {telem_config['environment']}")

# Telemetria local coleta m√©tricas adicionais:
# - Lat√™ncia de rede
# - Tentativas de reconex√£o  
# - Guardrails locais acionados
# - Cache hits/misses
```

### Dados Coletados Localmente
```python
# Exemplo de telemetria local adicional
{
    "sdk_version": "1.0.0",
    "local_latency_ms": 45,
    "guardrails_triggered": ["content_length"],
    "retry_attempts": 0,
    "local_cache_hit": False,
    "request_timestamp": "2025-07-29T01:30:00Z"
}
```

## üîß Configura√ß√£o Centralizada

### Configura√ß√£o por Ambiente
```python
from bradax.config import BradaxSDKConfig

# Configura√ß√£o autom√°tica baseada no ambiente
config = BradaxSDKConfig.from_environment()

# Configura√ß√£o para testes
test_config = BradaxSDKConfig.for_testing()

# Configura√ß√£o manual
config = BradaxSDKConfig(
    broker_url="https://llm.empresa.com",
    timeout=30,
    api_key_prefix="bradax_",
    environment="production",
    debug=False,
    custom_guardrails={},
    local_telemetry_enabled=True,
    telemetry_buffer_size=100
)
```

### Vari√°veis de Ambiente Suportadas
```bash
# URLs e conectividade
BRADAX_BROKER_URL=https://llm.empresa.com
BRADAX_TIMEOUT=30

# Configura√ß√£o de ambiente
BRADAX_ENVIRONMENT=production
BRADAX_DEBUG=false

# Telemetria local
BRADAX_LOCAL_TELEMETRY=true
BRADAX_TELEMETRY_BUFFER=100
```

## üé≠ Opera√ß√µes Avan√ßadas

### Context Manager
```python
# Uso com context manager (recomendado)
with BradaxClient("proj_token_123") as client:
    response = client.run_llm(
        prompt="Gere um resumo executivo...",
        model="gpt-4o-mini"
    )
    print(response["content"])
# Cliente √© automaticamente fechado
```

### Opera√ß√µes Batch
```python
# Processar m√∫ltiplas requisi√ß√µes
prompts = [
    "Analise documento 1",
    "Analise documento 2", 
    "Analise documento 3"
]

results = []
for prompt in prompts:
    response = client.run_llm(
        prompt=prompt,
        model="gpt-4o-mini",
        max_tokens=500
    )
    results.append(response)
```

### Streaming (quando suportado)
```python
# Stream de resposta em tempo real
for chunk in client.stream_llm(
    prompt="Escreva um relat√≥rio detalhado sobre...",
    model="gpt-4o",
    max_tokens=2000
):
    print(chunk, end="", flush=True)
```

## üîí Seguran√ßa e Autentica√ß√£o

### Tokens de Projeto
```python
# Token de projeto corporativo (formato padr√£o)
project_token = "proj_acme_2025_ai_assistant_001"
#                ^^^^_^^^^_^^^^_^^^^^^^^^^^^_^^^
#                proj_org_year_project_name_seq

# Valida√ß√£o autom√°tica de formato
client = BradaxClient(project_token)  # Valida automaticamente
```

### Headers Autom√°ticos
```python
# Headers adicionados automaticamente pelo SDK
{
    "Authorization": "Bearer proj_acme_2025_ai_assistant_001",
    "X-Project-Token": "proj_acme_2025_ai_assistant_001",
    "Content-Type": "application/json",
    "User-Agent": "bradax-sdk/1.0.0 (env:production)"
}
```

## üìã Tratamento de Erros

### Hierarquia de Exce√ß√µes
```python
from bradax.exceptions import (
    BradaxError,                  # Base exception
    BradaxAuthenticationError,    # Token inv√°lido/expirado
    BradaxConnectionError,        # Problemas de rede
    BradaxConfigurationError,     # Configura√ß√£o inv√°lida
    BradaxValidationError,        # Dados de entrada inv√°lidos
    BradaxBrokerError            # Erros do broker
)

try:
    response = client.run_llm(
        prompt="Analise estes dados...",
        model="modelo-inexistente"
    )
except BradaxValidationError as e:
    print(f"Dados inv√°lidos: {e}")
except BradaxAuthenticationError as e:
    print(f"Problema de autentica√ß√£o: {e}")
except BradaxBrokerError as e:
    print(f"Erro do broker: {e}")
except BradaxError as e:
    print(f"Erro geral: {e}")
```

### Tratamento Espec√≠fico
```python
# Retry autom√°tico para erros de rede
client = BradaxClient(
    project_token="proj_token_123",
    max_retries=3  # Tentar√° at√© 3 vezes em caso de falha de rede
)

# Logs detalhados para debug
client = BradaxClient(
    project_token="proj_token_123",
    verbose=True  # Ativa logs detalhados
)
```

## üèóÔ∏è Integra√ß√£o Corporativa

### Padr√£o Factory
```python
from bradax import create_client_for_project

# Factory method para projetos corporativos
client = create_client_for_project(
    project_name="ai_assistant",
    organization="acme",
    year=2025,
    environment="production"
)
# Gera automaticamente: proj_acme_2025_ai_assistant_001
```

### Configura√ß√£o de Projeto
```python
from bradax.config import ProjectConfig

# Configura√ß√£o espec√≠fica do projeto
project_config = ProjectConfig(
    project_id="proj_acme_2025_ai_assistant_001",
    api_key="bradax_secret_key_here",
    organization="ACME Corp",
    department="TI",
    budget_limit=5000.00,
    allowed_models=["gpt-4o-mini", "gpt-3.5-turbo"]
)

# Cliente com configura√ß√£o de projeto
client = BradaxClient(
    project_token=project_config.api_key,
    project_config=project_config
)
```

## üìä Monitoramento e Debug

### Health Check
```python
# Verificar status do broker
health = client.get_health()
print(f"Status: {health['status']}")
print(f"Servi√ßos: {health['services']}")
```

### Logs e Debug
```python
import logging

# Configurar logging do SDK
logging.getLogger("bradax").setLevel(logging.DEBUG)

# Cliente com debug ativo
client = BradaxClient(
    project_token="proj_token_123",
    verbose=True
)

# Logs autom√°ticos incluem:
# - Requisi√ß√µes enviadas
# - Respostas recebidas
# - Guardrails acionados
# - M√©tricas de performance
```

### M√©tricas Locais
```python
# Coletar m√©tricas da sess√£o atual
metrics = client.get_session_metrics()
print(f"Requisi√ß√µes: {metrics['total_requests']}")
print(f"Tempo total: {metrics['total_time_ms']}ms")
print(f"Guardrails acionados: {metrics['guardrails_triggered']}")
```

## üîÑ Casos de Uso Reais

### 1. An√°lise de Documentos
```python
def analyze_document(file_path: str) -> dict:
    with open(file_path, 'r') as f:
        content = f.read()
    
    with BradaxClient("proj_acme_2025_document_analyzer_001") as client:
        # Adicionar guardrail espec√≠fico para documentos
        client.add_custom_guardrail("document_validation", {
            "max_size_mb": 10,
            "allowed_formats": ["txt", "md", "docx"],
            "require_content": True
        })
        
        response = client.run_llm(
            prompt=f"Analise este documento e forne√ßa um resumo: {content}",
            model="gpt-4o-mini",
            max_tokens=1000
        )
        
        return {
            "summary": response["content"],
            "word_count": len(content.split()),
            "analysis_tokens": response.get("usage", {}).get("total_tokens", 0)
        }
```

### 2. Chatbot Corporativo
```python
class CorporateChatbot:
    def __init__(self, project_token: str):
        self.client = BradaxClient(project_token)
        
        # Configurar guardrails para chat
        self.client.add_custom_guardrail("chat_safety", {
            "max_message_length": 2000,
            "require_politeness": True,
            "corporate_context": True
        })
    
    def chat(self, user_message: str, context: str = "") -> str:
        prompt = f"""
        Contexto corporativo: {context}
        Pergunta do usu√°rio: {user_message}
        
        Responda de forma profissional e precisa.
        """
        
        response = self.client.run_llm(
            prompt=prompt,
            model="gpt-4o-mini",
            max_tokens=500,
            temperature=0.7
        )
        
        return response["content"]
```

### 3. Processamento em Lote
```python
def process_customer_feedback(feedback_list: list) -> dict:
    results = {
        "positive": [],
        "negative": [],
        "neutral": [],
        "total_processed": 0
    }
    
    with BradaxClient("proj_acme_2025_feedback_analyzer_001") as client:
        for feedback in feedback_list:
            try:
                response = client.run_llm(
                    prompt=f"Classifique este feedback como positivo, negativo ou neutro: {feedback}",
                    model="gpt-3.5-turbo",
                    max_tokens=50
                )
                
                sentiment = response["content"].lower().strip()
                if "positivo" in sentiment:
                    results["positive"].append(feedback)
                elif "negativo" in sentiment:
                    results["negative"].append(feedback)
                else:
                    results["neutral"].append(feedback)
                    
                results["total_processed"] += 1
                
            except Exception as e:
                print(f"Erro processando feedback: {e}")
    
    return results
```

## üè¢ Conformidade Corporativa

### Pr√°ticas Recomendadas
1. **Sempre usar context managers** para garantir fechamento de recursos
2. **Configurar guardrails apropriados** para cada caso de uso
3. **Monitorar telemetria local** para otimiza√ß√£o
4. **Tratar exce√ß√µes espec√≠ficas** para melhor experi√™ncia
5. **Usar configura√ß√£o centralizada** para ambientes

### Auditoria e Compliance
```python
# Todas as opera√ß√µes s√£o automaticamente auditadas
# Dados incluem:
# - Timestamp da requisi√ß√£o
# - Token do projeto usado
# - Modelo e par√¢metros
# - Conte√∫do (se configurado)
# - Guardrails acionados
# - M√©tricas de performance
```

---

> **üíº Nota Corporativa:** Este SDK foi projetado para ambientes empresariais que exigem controle total, auditoria completa e conformidade com pol√≠ticas corporativas. Todas as opera√ß√µes s√£o transparentes e audit√°veis.
